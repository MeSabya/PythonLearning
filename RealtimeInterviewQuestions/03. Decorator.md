## Thread-Safe Singleton Decorator
<details>

```python
import threading
from functools import wraps

def thread_safe_singleton(cls):
    instances = {}
    lock = threading.Lock()

    @wraps(cls)
    def get_instance(*args, **kwargs):
        if cls not in instances:
            with lock:
                if cls not in instances:  # Double-checked locking
                    instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

```
</details>


## How do you decorate all methods of a class (e.g., for tracing or auth)?

```python
def method_decorator(method):
    def wrapper(*args, **argv):
        print("calling method name", method.__name__)
        return method(*args, **argv)
    return wrapper
    
def decorate_all_methods(cls):
    for attr in (dir(cls)):
        #print("Each attr of class", getattr(cls, attr))
        if callable(getattr(cls, attr)) and not attr.startswith("__"):
            setattr(cls, attr, method_decorator(getattr(cls, attr)))
    return cls
        

@decorate_all_methods
class Base:
    def process(self):
        print("Process is called")
    def func2(self):
        print("func2 is called")
    def _func3(self):
        print("func3 is called")

b = Base()
b.process()
    

```

