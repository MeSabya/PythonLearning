## Design a plugin system where plugins automatically register themselves upon import.
Designing a plugin system where plugins automatically register themselves upon import is a classic, real-world Python pattern. Itâ€™s used in Django, Flask extensions, setuptools entry points.
When someone writes a new plugin module and imports it (manually or via discovery):

It should register itself automatically

The core system should not need to explicitly register every plugin

<details> 

```go

### 1. Plugin Registry

```python
class PluginRegistry:
    _plugins = {}

    @classmethod
    def register(cls, name, plugin_cls):
        cls._plugins[name] = plugin_cls

    @classmethod
    def get_plugins(cls):
        return dict(cls._plugins)
```

### 2. Base Plugin Class (with metaclass auto-registration)

```python
class PluginMeta(type):
    def __init__(cls, name, bases, clsdict):
        if name != "BasePlugin":  # Skip base class itself
            PluginRegistry.register(name, cls)
        super().__init__(name, bases, clsdict)

class BasePlugin(metaclass=PluginMeta):
    def run(self):
        raise NotImplementedError
```

### 3. Define Plugins (in separate files/modules)

```python
# plugin_foo.py
from base import BasePlugin

class FooPlugin(BasePlugin):
    def run(self):
        print("FooPlugin running")
```

```python
# plugin_bar.py
from base import BasePlugin

class BarPlugin(BasePlugin):
    def run(self):
        print("BarPlugin running")
```

### 4. Main Program: Discover Plugins

```python
# main.py
import plugin_foo
import plugin_bar

from plugin_registry import PluginRegistry

for name, plugin_cls in PluginRegistry.get_plugins().items():
    print(f"Running {name}")
    plugin_cls().run()
```

### âœ… Output

```sql
Running FooPlugin
FooPlugin running
Running BarPlugin
BarPlugin running
```
ðŸŽ‰ No explicit registration in main.py â€” plugins registered at import time.

</details>

## Build a simple ORM that maps class attributes to database fields using meta-programming techniques.

Let's build a very simple ORM (Object Relational Mapper) using meta-programming in Python â€” specifically using metaclasses. This ORM will:

- Map Python classes to tables
- Map class attributes to table columns
- Generate basic SQL for CREATE TABLE, INSERT, and SELECT

<details>

```go
# orm/fields.py
class Field:
    def __init__(self, column_type):
        self.column_type = column_type

class StringField(Field):
    def __init__(self, max_length=255):
        super().__init__(f"VARCHAR({max_length})")

class IntegerField(Field):
    def __init__(self):
        super().__init__("INTEGER")

# orm/metabase.py
class ModelMeta(type):
    def __new__(mcs, name, bases, attrs):
        print("__new__ is called on model meta", name, attrs)
        if name == 'BaseModel':
            return super().__new__(mcs, name, bases, attrs)

        mappings = {}
        for key, value in attrs.items():
            if isinstance(value, Field):
                mappings[key] = value

        cls = super().__new__(mcs, name, bases, attrs)
        cls.__mappings__ = mappings
        cls.__table__ = name.lower()
        return cls
        
# orm/base.py
class BaseModel(metaclass=ModelMeta):
    def __init__(self, **kwargs):
        print("Base Model init is called ...")
        for key in self.__mappings__:
            setattr(self, key, kwargs.get(key))

    def save(self):
        fields = []
        values = []
        for key, field in self.__mappings__.items():
            fields.append(key)
            values.append(repr(getattr(self, key)))
        sql = f"INSERT INTO {self.__table__} ({', '.join(fields)}) VALUES ({', '.join(values)});"
        print("SQL:", sql)

    @classmethod
    def create_table(cls):
        columns = [f"{name} {field.column_type}" for name, field in cls.__mappings__.items()]
        sql = f"CREATE TABLE {cls.__table__} ({', '.join(columns)});"
        print("SQL:", sql)


class User(BaseModel):
    print("User is initializing")
    id = IntegerField()
    name = StringField()
    email = StringField()

print("Create table is called")
User.create_table()
u = User(id=1, name="Alice", email="alice@example.com")
u.save()
```
</details>
